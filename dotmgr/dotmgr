#!/usr/bin/env python3
#
# This file is part of dotmgr.
#
# dotmgr is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# dotmgr is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with dotmgr.  If not, see <http://www.gnu.org/licenses/>.
"""Dotfile manager

A small script that can help you maintain your dotfiles across several devices.
"""

from argparse import ArgumentParser, RawDescriptionHelpFormatter, REMAINDER
from os import environ, makedirs
from os.path import dirname, exists, expanduser, isdir, isfile
from socket import gethostname
from textwrap import dedent

from dotmgr.manager import Manager
from pkg_resources import require
from git.cmd import Git
from git.exc import GitCommandError


DEFAULT_DOTFILE_REPOSITORY_PATH = '~/repositories/dotfiles'
DEFAULT_DOTFILE_STAGE_PATH = '~/.local/share/dotmgr/stage'
DEFAULT_DOTFILE_TAG_CONFIG_PATH = '.config/dotmgr/tags.conf'


def prepare_argument_parser():
    """Creates and configures the argument parser for the CLI.
    """
    parser = ArgumentParser(description='Generalize / specialize dotfiles',
                            epilog=dedent("""\
                    default paths and environment variables:
                    General dotfiles are read from / written to {}.
                    You can set the environment variable $DOTMGR_REPO to change this.

                    The default stage directory is {}.
                    This can be overridden with $DOTMGR_STAGE.

                    Tags are read from ~/{}, which can be changed
                    by setting $DOTMGR_TAG_CONF.

                    version:
                    This is version {} of dotmgr.
                            """).format(DEFAULT_DOTFILE_REPOSITORY_PATH,
                                        DEFAULT_DOTFILE_STAGE_PATH,
                                        DEFAULT_DOTFILE_TAG_CONFIG_PATH,
                                        require("dotmgr")[0].version),
                            formatter_class=RawDescriptionHelpFormatter,
                            add_help=True)
    acts = parser.add_argument_group('actions').add_mutually_exclusive_group()
    acts.add_argument('-A', dest='add', metavar='file',
                      help='move a dotfile from your home directory to the stage, link it back '
                           'and create a generalized version in the repository')
    acts.add_argument('-D', dest='delete', action='store_true',
                      help='remove a dotfile from the stage and delete its symlink')
    acts.add_argument('-G', dest='generalize', action='store_true',
                      help='generalize a dotfile currently on stage')
    acts.add_argument('-I', dest='init', nargs='?', const='', metavar='repo',
                      help='clone a given dotfile repository or initialize an empty one')
    acts.add_argument('-S', dest='specialize', action='store_true',
                      help='specialize a dotfile from the repository')
    acts.add_argument('-V', dest='command', nargs=REMAINDER, metavar='arg',
                      help='run a git command in the dotfile repository')
    parser.add_argument('file', nargs='?', default=False,
                        help='a path to a dotfile - if omitted, the requested action is performed '
                             'for all dotfiles')
    flags = parser.add_argument_group('modifiers')
    flags.add_argument('-b', dest='bootstrap', action='store_true',
                       help='read the tag configuration directly from the repository instead of '
                            'your home directory')
    flags.add_argument('-l', dest='link', action='store_true',
                       help='place symlinks to files on stage (use with -S)')
    flags.add_argument('-r', dest='rm', action='store_true',
                       help='also remove the file from the dotfile repository (use with -D '
                            'and a dotfile path)')
    parser.add_argument('-v', dest='verbose', action='store_true',
                        help='enable verbose output (useful for debugging)')
    return parser

def prepare_dotfile_repository_path(verify, verbose):
    """Synthesizes the path to the dotfile repository.

    If DOTMGR_REPO is defined, it is read from the environment and returned.
    Otherwise the DEFAULT_DOTFILE_REPOSITORY_PATH is used.

    Args:
        verify:  If set to `True`, the program exits with an error message if the chosen path does
                 not point to a directory.
        verbose: If set to `True`, this function generates debug messages.

    Returns:
        The (absolute) path to the dotfile repository.
    """
    dotfile_repository_path = expanduser(DEFAULT_DOTFILE_REPOSITORY_PATH)
    if 'DOTMGR_REPO' in environ:
        dotfile_repository_path = environ['DOTMGR_REPO']

    if verify and not isdir(dotfile_repository_path):
        print('Error: dotfile repository {} does not exist'.format(dotfile_repository_path))
        exit()

    if verbose:
        print('Using dotfile repository at {}'.format(dotfile_repository_path))
    return dotfile_repository_path

def prepare_dotfile_stage_path(verbose):
    """Synthesizes the path to the dotfile stage directory.

    If DOTMGR_STAGE is defined, it is read from the environment and returned.
    Otherwise the DEFAULT_DOTFILE_STAGE_PATH is used.
    If the chosen directory does not exist, it is created automatically.

    Args:
        verbose: If set to `True`, this function generates debug messages.

    Returns:
        The (absolute) path to the dotfile stage directory.
    """
    dotfile_stage_path = expanduser(DEFAULT_DOTFILE_STAGE_PATH)
    if 'DOTMGR_STAGE' in environ:
        dotfile_stage_path = environ['DOTMGR_STAGE']

    if not isdir(dotfile_stage_path):
        if verbose:
            print('Preparing stage at {}'.format(dotfile_stage_path))
        makedirs(dotfile_stage_path)
    elif verbose:
        print('Using stage at {}'.format(dotfile_stage_path))
    return dotfile_stage_path

def prepare_tag_config_path(bootstrap, dotfile_repository_path, verify, verbose):
    """Synthesizes the path to the dotfile stage directory.

    If DOTMGR_TAG_CONF is defined, it is read from the environment and returned.
    Otherwise the DEFAULT_DOTFILE_STAGE_PATH is appended to the path of the user's home directory.
    If the chosen path does not point to a file, the program exits with an error message.

    Args:
        bootstrap: If `True`, a path to the config within in the dotfile repository is returned.
        dotfile_repository_path: The path to the dotfile repository (may be `None` if `boostrap` is
                                 not set).
        verify:  If set to `True`, the program exits with an error message if the chosen path does
                 not point to a file.
        verbose: If set to `True`, this function generates debug messages.

    Returns:
        The (absolute) path to the tag configuration file.
    """
    if bootstrap:
        dotfile_tag_config_path = dotfile_repository_path + '/' + DEFAULT_DOTFILE_TAG_CONFIG_PATH
    else:
        dotfile_tag_config_path = expanduser('~/' + DEFAULT_DOTFILE_TAG_CONFIG_PATH)
        if 'DOTMGR_TAG_CONF' in environ:
            dotfile_tag_config_path = environ['DOTMGR_TAG_CONF']

    if verify and not isfile(dotfile_tag_config_path):
        print('Error: Tag configuration file "{}" not found!\n'
              '       You can use -b to bootstrap it from your dotfile repository\n'
              '       or set $DOTMGR_TAG_CONF to override the default path.'\
              .format(dotfile_tag_config_path))
        exit()

    if verbose:
        print('Using dotfile tags config at {}'.format(dotfile_tag_config_path))
    return dotfile_tag_config_path

def main():
    """Program entry point.

    Where things start to happen...
    """
    # Check and parse arguments
    parser = prepare_argument_parser()
    args = parser.parse_args()
    init = args.init is not None

    # Enable verbose mode if requested
    verbose = False
    if args.verbose:
        verbose = True

    # Prepare paths
    dotfile_repository_path = prepare_dotfile_repository_path(not init, verbose)
    dotfile_stage_path = prepare_dotfile_stage_path(verbose)
    dotfile_tag_config_path = prepare_tag_config_path(args.bootstrap or init,
                                                      dotfile_repository_path,
                                                      not init,
                                                      verbose)

    def init_repo():
        """Initializes an empty git repository and creates an initial tag configuration.
        """
        print('Initializing empty repository in {}'.format(dotfile_repository_path))
        if isdir(dotfile_repository_path):
            print('Error: The target directory already exists.')
            exit()
        Git().init(dotfile_repository_path)
        print('Creating initial tag configuration')
        makedirs(dirname(dotfile_tag_config_path))
        with open(dotfile_tag_config_path, 'w') as tag_config:
            tag_config.write('{0}: {0}'.format(gethostname()))

    # If desired, initialize or clone the dotfile repository and exit
    if init:
        try:
            if args.init:
                print('Cloning {} into {}'.format(args.init, dotfile_repository_path))
                Git().clone(args.init, dotfile_repository_path)
            else:
                init_repo()
        except GitCommandError as error:
            print(error.stderr)
        exit()

    # Fire up dotfile manager instance
    manager = Manager(dotfile_repository_path, dotfile_stage_path, dotfile_tag_config_path, verbose)

    def delete():
        """Helper function for the -D action.
        """
        if args.file:
            manager.delete(args.file, args.rm)
        else:
            manager.delete_all()

    def generalize():
        """Helper function for the -G action.
        """
        if args.file:
            manager.generalize(args.file)
        else:
            manager.generalize_all()

    def specialize():
        """Helper function for the -S action.
        """
        if args.file:
            manager.specialize(args.file, args.link)
        else:
            manager.specialize_all(args.link)

    # Execute selected action
    if args.add:
        manager.add(args.add)
    elif args.delete:
        delete()
    elif args.generalize:
        generalize()
    elif args.specialize:
        specialize()
    elif args.command:
        manager.execute_git(args.command)
    elif not init:
        parser.print_help()

if __name__ == "__main__":
    main()
